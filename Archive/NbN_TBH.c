#pragma config(Sensor, dgtl1,  EncoderRight,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  EncoderLeft,    sensorQuadEncoder)
#pragma config(Motor,  port1,           LMidDrive,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftDrive,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           Motor_FW3,     tmotorVex393_MC29, openLoop, encoderPort, dgtl3)
#pragma config(Motor,  port4,           Motor_FW4,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           conveyor,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Motor_FW1,     tmotorVex393_MC29, openLoop, reversed, encoderPort, dgtl1)
#pragma config(Motor,  port8,           Motor_FW2,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           RightDrive,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port10,          RMidDrive,     tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!

// Update inteval (in mS) for the flywheel control loop
#define FW_LOOP_SPEED              25

// Maximum power we want to send to the flywheel motors
#define FW_MAX_POWER              127

// encoder counts per revolution depending on motor
#define MOTOR_TPR_269           240.448
#define MOTOR_TPR_393R          261.333
#define MOTOR_TPR_393S          392
#define MOTOR_TPR_393T          627.2
#define MOTOR_TPR_QUAD          360.0

// Structure to gather all the flywheel ralated data
typedef struct _fw_controller {
	long            counter;                ///< loop counter used for debug

	// encoder tick per revolution
	float           ticks_per_rev;          ///< encoder ticks per revolution

	// Encoder
	long            e_current;              ///< current encoder count
	long            e_last;                 ///< current encoder count

	// velocity measurement
	float           v_current;              ///< current velocity in rpm
	long            v_time;                 ///< Time of last velocity calculation

	// TBH control algorithm variables
	long            target;                 ///< target velocity
	long            current;                ///< current velocity
	long            last;                   ///< last velocity
	float           error;                  ///< error between actual and target velocities
	float           last_error;             ///< error last time update called
	float           gain;                   ///< gain
	float           drive;                  ///< final drive out of TBH (0.0 to 1.0)
	float           drive_at_zero;          ///< drive at last zero crossing
	long            first_cross;            ///< flag indicating first zero crossing
	float           drive_approx;           ///< estimated open loop drive

	// final motor drive
	long            motor_drive;            ///< final motor control value
} fw_controller;

// Make the controller global for easy debugging
static  fw_controller   flywheel;

//
//
//

// Structure to gather all the flywheel ralated data
typedef struct _fw_controller2 {
	long            counter2;                ///< loop counter used for debug

	// encoder tick per revolution
	float           ticks_per_rev2;          ///< encoder ticks per revolution

	// Encoder
	long            e_current2;              ///< current encoder count
	long            e_last2;                 ///< current encoder count

	// velocity measurement
	float           v_current2;              ///< current velocity in rpm
	long            v_time2;                 ///< Time of last velocity calculation

	// TBH control algorithm variables
	long            target2;                 ///< target velocity
	long            current2;                ///< current velocity
	long            last2;                   ///< last velocity
	float           error2;                  ///< error between actual and target velocities
	float           last_error2;             ///< error last time update called
	float           gain2;                   ///< gain
	float           drive2;                  ///< final drive out of TBH (0.0 to 1.0)
	float           drive_at_zero2;          ///< drive at last zero crossing
	long            first_cross2;            ///< flag indicating first zero crossing
	float           drive_approx2;           ///< estimated open loop drive

	// final motor drive
	long            motor_drive2;            ///< final motor control value
} fw_controller2;

// Make the controller global for easy debugging
static  fw_controller2   flywheel2;

/*-----------------------------------------------------------------------------*/
/** @brief      Set the flywheen motors                                        */
/** @param[in]  value motor control value                                      */
/*-----------------------------------------------------------------------------*/
void
FwMotorSet( int value )
{
	motor[ Motor_FW1 ] = value;
	motor[ Motor_FW2 ] = value;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Get the flywheen motor encoder count                           */
/*-----------------------------------------------------------------------------*/
long
FwMotorEncoderGet()
{
	return( abs(nMotorEncoder[ Motor_FW1 ] ));
}

/*-----------------------------------------------------------------------------*/
/** @brief      Set the controller position                                    */
/** @param[in]  fw pointer to flywheel controller structure                    */
/** @param[in]  desired velocity                                               */
/** @param[in]  predicted_drive estimated open loop motor drive                */
/*-----------------------------------------------------------------------------*/
void
FwVelocitySet( fw_controller *fw, int velocity, float predicted_drive )
{
	// set target velocity (motor rpm)
	fw->target        = velocity;

	// Set error so zero crossing is correctly detected
	fw->error         = fw->target - fw->current;
	fw->last_error    = fw->error;

	// Set predicted open loop drive value
	fw->drive_approx  = predicted_drive;
	// Set flag to detect first zero crossing
	fw->first_cross   = 1;
	// clear tbh variable
	fw->drive_at_zero = 0;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Calculate the current flywheel motor velocity                  */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwCalculateSpeed( fw_controller *fw )
{
	int     delta_ms;
	int     delta_enc;

	// Get current encoder value
	fw->e_current = FwMotorEncoderGet();

	// This is just used so we don't need to know how often we are called
	// how many mS since we were last here
	delta_ms   = nSysTime - fw->v_time;
	fw->v_time = nSysTime;

	// Change in encoder count
	delta_enc = (fw->e_current - fw->e_last);

	// save last position
	fw->e_last = fw->e_current;

	// Calculate velocity in rpm
	fw->v_current = (1000.0 / delta_ms) * delta_enc * 60.0 / fw->ticks_per_rev;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Update the velocity tbh controller variables                   */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwControlUpdateVelocityTbh( fw_controller *fw )
{
	// calculate error in velocity
	// target is desired velocity
	// current is measured velocity
	fw->error = fw->target - fw->current;

	// Use Kp as gain
	fw->drive =  fw->drive + (fw->error * fw->gain);

	// Clip - we are only going forwards
	if( fw->drive > 1 )
		fw->drive = 1;
	if( fw->drive < 0 )
		fw->drive = 0;

	// Check for zero crossing
	if( sgn(fw->error) != sgn(fw->last_error) ) {
		// First zero crossing after a new set velocity command
		if( fw->first_cross ) {
			// Set drive to the open loop approximation
			fw->drive = fw->drive_approx;
			fw->first_cross = 0;
		}
		else
			fw->drive = 0.5 * ( fw->drive + fw->drive_at_zero );

		// Save this drive value in the "tbh" variable
		fw->drive_at_zero = fw->drive;
	}

	// Save last error
	fw->last_error = fw->error;
}


//
//
//
//Right Side of Flywheels
//
//


/*-----------------------------------------------------------------------------*/
/** @brief      Set the flywheen motors                                        */
/** @param[in]  value motor control value                                      */
/*-----------------------------------------------------------------------------*/
void
FwMotorSet2( int value )
{
	motor[ Motor_FW3 ] = value;
	motor[ Motor_FW4 ] = value;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Get the flywheen motor encoder count                           */
/*-----------------------------------------------------------------------------*/
long
FwMotorEncoderGet2()
{
	return( abs(nMotorEncoder[ Motor_FW3 ] ));
}

/*-----------------------------------------------------------------------------*/
/** @brief      Set the controller position                                    */
/** @param[in]  fw pointer to flywheel controller structure                    */
/** @param[in]  desired velocity                                               */
/** @param[in]  predicted_drive estimated open loop motor drive                */
/*-----------------------------------------------------------------------------*/
void
FwVelocitySet2( fw_controller2 *fw, int velocity2, float predicted_drive2 )
{
	// set target velocity (motor rpm)
	fw->target2        = velocity2;

	// Set error so zero crossing is correctly detected
	fw->error2         = fw->target2 - fw->current2;
	fw->last_error2    = fw->error2;

	// Set predicted open loop drive value
	fw->drive_approx2  = predicted_drive2;
	// Set flag to detect first zero crossing
	fw->first_cross2   = 1;
	// clear tbh variable
	fw->drive_at_zero2 = 0;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Calculate the current flywheel motor velocity                  */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwCalculateSpeed2( fw_controller2 *fw )
{
	int     delta_ms2;
	int     delta_enc2;

	// Get current encoder value
	fw->e_current2 = FwMotorEncoderGet2();

	// This is just used so we don't need to know how often we are called
	// how many mS since we were last here
	delta_ms2   = nSysTime - fw->v_time2;
	fw->v_time2 = nSysTime;

	// Change in encoder count
	delta_enc2 = (fw->e_current2 - fw->e_last2);

	// save last position
	fw->e_last2 = fw->e_current2;

	// Calculate velocity in rpm
	fw->v_current2 = (1000.0 / delta_ms2) * delta_enc2 * 60.0 / fw->ticks_per_rev2;
}

/*-----------------------------------------------------------------------------*/
/** @brief      Update the velocity tbh controller variables                   */
/** @param[in]  fw pointer to flywheel controller structure                    */
/*-----------------------------------------------------------------------------*/
void
FwControlUpdateVelocityTbh2( fw_controller2 *fw )
{
	// calculate error in velocity
	// target is desired velocity
	// current is measured velocity
	fw->error2 = fw->target2 - fw->current2;

	// Use Kp as gain
	fw->drive2 =  fw->drive2 + (fw->error2 * fw->gain2);

	// Clip - we are only going forwards
	if( fw->drive2 > 1 )
		fw->drive2 = 1;
	if( fw->drive2 < 0 )
		fw->drive2 = 0;

	// Check for zero crossing
	if( sgn(fw->error2) != sgn(fw->last_error2) ) {
		// First zero crossing after a new set velocity command
		if( fw->first_cross2 ) {
			// Set drive to the open loop approximation
			fw->drive2 = fw->drive_approx2;
			fw->first_cross2 = 0;
		}
		else
			fw->drive2 = 0.5 * ( fw->drive2 + fw->drive_at_zero2 );

		// Save this drive value in the "tbh" variable
		fw->drive_at_zero2 = fw->drive2;
	}

	// Save last error
	fw->last_error2 = fw->error2;
}

/*-----------------------------------------------------------------------------*/
/** @brief     Task to control the velocity of the flywheel                    */
/*-----------------------------------------------------------------------------*/
task
FwControlTask2()
{
	fw_controller *fw = &flywheel;
	fw_controller2 *fw2 = &flywheel2;

	// Set the gain
	fw->gain = 0.00025;

	// Set the gain
	fw2->gain2 = 0.00025;

	// We are using Speed geared motors
	// Set the encoder ticks per revolution
	fw->ticks_per_rev = MOTOR_TPR_393R;

	// We are using Speed geared motors
	// Set the encoder ticks per revolution
	fw2->ticks_per_rev2 = MOTOR_TPR_393R;

	while(1)
	{
		// debug counter
		fw->counter++;

		// Calculate velocity
		FwCalculateSpeed( fw );

		// Set current speed for the tbh calculation code
		fw->current = fw->v_current;

		// Do the velocity TBH calculations
		FwControlUpdateVelocityTbh( fw ) ;

		// Scale drive into the range the motors need
		fw->motor_drive  = (fw->drive * FW_MAX_POWER) + 0.5;

		// Final Limit of motor values - don't really need this
		if( fw->motor_drive >  127 ) fw->motor_drive =  127;
		if( fw->motor_drive < -127 ) fw->motor_drive = -127;

		// and finally set the motor control value
		FwMotorSet( fw->motor_drive );

		//
		//
		//

		// debug counter
		fw2->counter2++;

		// Calculate velocity
		FwCalculateSpeed2( fw2 );

		// Set current speed for the tbh calculation code
		fw2->current2 = fw2->v_current2;

		// Do the velocity TBH calculations
		FwControlUpdateVelocityTbh2( fw2 ) ;

		// Scale drive into the range the motors need
		fw2->motor_drive2  = (fw2->drive2 * FW_MAX_POWER) + 0.5;

		// Final Limit of motor values - don't really need this
		if( fw2->motor_drive2 >  127 ) fw2->motor_drive2 =  127;
		if( fw2->motor_drive2 < -127 ) fw2->motor_drive2 = -127;

		// and finally set the motor control value
		FwMotorSet2( fw2->motor_drive2 );

		// Run at somewhere between 20 and 50mS
		wait1Msec( FW_LOOP_SPEED );
	}
}
/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	// Set bStopTasksBetweenModes to false if you want to keep user created tasks running between
	// Autonomous and Tele-Op modes. You will need to manage all user created tasks if set to false.
	bStopTasksBetweenModes = true;

	// All activities that occur before the competition starts
	// Example: clearing encoders, setting servo positions, ...
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// .....................................................................................
	// Insert user code here.
	// .....................................................................................

	AutonomousCodePlaceholderForTesting();  // Remove this function call once you have "real" code.
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{

	char  str[32];

	bLCDBacklight = true;

	// Start the flywheel control task
	//	startTask( FwControlTask );
	startTask( FwControlTask2 );

	// Main user control loop
	while(1)
	{
		// Different speeds set by buttons
		if( vexRT[ Btn8L ] == 1 )             // 485 for full field, 420 for straight edge (fast load)
		{
			FwVelocitySet( &flywheel, 485, 0.55 );
			FwVelocitySet2( &flywheel2, 485, 0.55 );
		}
		if( vexRT[ Btn8U ] == 1 )
		{
			FwVelocitySet( &flywheel, 460, 0.38 );
			FwVelocitySet2( &flywheel2, 460, 0.38 );
		}
		if( vexRT[ Btn8R ] == 1 )
		{
			FwVelocitySet( &flywheel, 420, 0.2 );
			FwVelocitySet2( &flywheel2, 420, 0.2 );
		}
		if( vexRT[ Btn8D ] == 1 )
		{
			FwVelocitySet( &flywheel, 00, 0 );
			FwVelocitySet2( &flywheel2, 00, 0 );
		}

		if(vexRT[Btn6U] == 1)
		{
			motor[conveyor] = 63;
		}
		else if( vexRT[Btn6D] == 1)
		{
			motor[conveyor] = 0;
		}

		motor[LeftDrive] = -(vexRT[Ch3] + vexRT[Ch4])/2;
		motor[RightDrive] = -(vexRT[Ch3] - vexRT[Ch4])/2;
		motor[LMidDrive] = -(vexRT[Ch3] + vexRT[Ch4])/2;
		motor[RMidDrive] = -(vexRT[Ch3] - vexRT[Ch4])/2;

		// Display useful things on the LCD
		sprintf( str, "%4d %4d  %5.2f", flywheel.target,  flywheel.current, nImmediateBatteryLevel/1000.0 );
		displayLCDString(0, 0, str );

		sprintf( str, "%4d %4d  %5.2f", flywheel2.target2,  flywheel2.current2, nImmediateBatteryLevel/1000.0 );
		displayLCDString(1, 0, str );

		//	sprintf( str, "%4.2f %4.2f ", flywheel.drive, flywheel.drive_at_zero );
		//	displayLCDString(1, 0, str );

		// Don't hog the cpu :)
		wait1Msec(10);


		UserControlCodePlaceholderForTesting(); // Remove this function call once you have "real" code.
	}
}
